{"title":"Structured Output","markdown":{"yaml":{"title":"Structured Output"},"headingText":"Extracting facts from text","containsRefs":false,"markdown":"\n\n\n\n\nA very useful feature of OpenAI's API is the ability to return structured data. This is useful for a variety of reasons, but one of the most common is to return a JSON object.\nHere is the official [OpenAI documentation for structured output](https://platform.openai.com/docs/guides/structured-outputs).\n\nOpenAI's API can return responses in structured formats like JSON, making it easier to:\n\n- Parse and process responses programmatically\n- Ensure consistent output formats\n- Integrate with existing systems and databases\n\nWhen using structured output, you can:\n\n1. Define specific JSON schemas for your responses\n2. Get predictable data structures instead of free-form text\n3. Reduce the need for additional parsing/processing\n\nCommon use cases include:\n\n- Extracting specific fields from text\n- Converting unstructured data into structured formats\n- Creating standardized API responses\n- Building data pipelines with LLM outputs\n\n\nPut very simply, the difference between structured and unstructured output is illustrated by the following example: Imagine you want to know the current weather in a city.\n\n**Unstructured output:** The response is a free-form text response.\n\n> \"The current weather in Bern is 8 degrees Celsius with partly cloudy skies.\"\n\nor \n\n> The weather in Bern is 10¬∞ with rain.\n\n**Structured output:** The response is a JSON object with the weather information.\n```json\n{\"city\": \"Bern\", \n\"temperature\": 8, \n\"scale\": \"Celsius\",\n\"condition\": \"partly cloudy\"}\n```\n\nThe benefit of structured output is that it is easier to parse and process programmatically. A further advantage is that we can use a data validation library like Pydantic to ensure that the response is in the expected format.\n\nTo use this feature, we first need to install the `pydantic` package.\n\n```bash\npip install pydantic\n```\n\nThen we can define a Pydantic model to describe the expected structure of the response.\n\n```python\nfrom pydantic import BaseModel\n\nclass Weather(BaseModel):\n    city: str\n    temperature: float\n    scale: str\n    condition: str\n```\n\nWe can use this object as the `response_format` parameter in the `openai.ChatCompletion.create` method.\n\n\nHere is an example of how to use structured output. Since a pre-trained model is not actually able to provide weather information without calling a weather API, we will use a prompt that asks the model to give us some facts contained in a text about a composer. For example, we want to extract the composer's name, the year of birth and death, and the country of origin, the genre of music they worked in, and some key works.\n\n\n\nNext we define a Pydantic model to describe the expected structure of the response. The fields of the model correspond to the facts we want to extract.\n\nIn this case, we want to extract the following facts (if available):\n\n- The composer's name\n- The year of birth\n- The year of death\n- The country of origin\n- The genre of music they worked in\n- Some key works    \n\n\nThis is a Pydantic model that defines a structured data format for storing information about composers:\n\n1. `class ComposerFactSheet(BaseModel)`: Creates a new class that inherits from Pydantic's `BaseModel`, giving it data validation capabilities.\n2. `name: str`: A required field for the composer's name.\n3. `birth_year: int`: A required field for the year of birth.\n4. `death_year: Optional[int] = None`: An optional field for the year of death.\n5. `country: str`: A required field for the country of origin.\n6. `genre: str`: A required field for the genre of music.\n7. `key_works: List[str]`: A required field for a list of key works.\n\n\nWhen used, this model will:\n\n- Validate that all required fields are present\n- Convert input data to the correct types when possible\n- Raise validation errors if data doesn't match the schema\n\nExample output:\n\n```python\ncomposer = ComposerFactSheet(\n    name=\"Johann Sebastian Bach\",\n    birth_year=1685,\n    death_year=1750,\n    country=\"Germany\",\n    genre=\"Baroque\",\n    key_works=[\"Mass in B minor\", \"The Well-Tempered Clavier\"]\n)\n```\n\n\n\nLet's try this with a suitable system prompt and a short paragraph about [Eric Satie](https://en.wikipedia.org/wiki/Erik_Satie). We will use the `GPT-4o` model for this.\n\n\nThe f-string (formatted string literal)is used to embed the `text` variable into the `user_message` string.\nThis allows us to dynamically construct the prompt that will be sent to the language model,\nincluding the specific text we want it to extract structured information from.\nWithout the f-string, we would need to concatenate the strings manually, which can be more error-prone and less readable.\n\n\n\nWe can now access the fields of the `factsheet` object.\n\nLet's try another example. This time we will attempt to extract information from a paragraph in which some of the information is missing.\n\n\nAn obvious next step would be to improve our prompting strategy, so that the model indicates which fields it is able to fill in, and which fields are associated with uncertain or missing information.\n\n## Creating a reusable function\nHowever, we will focus on making our code more resuable by creating a function that can be called with different texts.\n","srcMarkdownNoYaml":"\n\n\n\n\nA very useful feature of OpenAI's API is the ability to return structured data. This is useful for a variety of reasons, but one of the most common is to return a JSON object.\nHere is the official [OpenAI documentation for structured output](https://platform.openai.com/docs/guides/structured-outputs).\n\nOpenAI's API can return responses in structured formats like JSON, making it easier to:\n\n- Parse and process responses programmatically\n- Ensure consistent output formats\n- Integrate with existing systems and databases\n\nWhen using structured output, you can:\n\n1. Define specific JSON schemas for your responses\n2. Get predictable data structures instead of free-form text\n3. Reduce the need for additional parsing/processing\n\nCommon use cases include:\n\n- Extracting specific fields from text\n- Converting unstructured data into structured formats\n- Creating standardized API responses\n- Building data pipelines with LLM outputs\n\n\nPut very simply, the difference between structured and unstructured output is illustrated by the following example: Imagine you want to know the current weather in a city.\n\n**Unstructured output:** The response is a free-form text response.\n\n> \"The current weather in Bern is 8 degrees Celsius with partly cloudy skies.\"\n\nor \n\n> The weather in Bern is 10¬∞ with rain.\n\n**Structured output:** The response is a JSON object with the weather information.\n```json\n{\"city\": \"Bern\", \n\"temperature\": 8, \n\"scale\": \"Celsius\",\n\"condition\": \"partly cloudy\"}\n```\n\nThe benefit of structured output is that it is easier to parse and process programmatically. A further advantage is that we can use a data validation library like Pydantic to ensure that the response is in the expected format.\n\nTo use this feature, we first need to install the `pydantic` package.\n\n```bash\npip install pydantic\n```\n\nThen we can define a Pydantic model to describe the expected structure of the response.\n\n```python\nfrom pydantic import BaseModel\n\nclass Weather(BaseModel):\n    city: str\n    temperature: float\n    scale: str\n    condition: str\n```\n\nWe can use this object as the `response_format` parameter in the `openai.ChatCompletion.create` method.\n\n## Extracting facts from text\n\nHere is an example of how to use structured output. Since a pre-trained model is not actually able to provide weather information without calling a weather API, we will use a prompt that asks the model to give us some facts contained in a text about a composer. For example, we want to extract the composer's name, the year of birth and death, and the country of origin, the genre of music they worked in, and some key works.\n\n\n\nNext we define a Pydantic model to describe the expected structure of the response. The fields of the model correspond to the facts we want to extract.\n\nIn this case, we want to extract the following facts (if available):\n\n- The composer's name\n- The year of birth\n- The year of death\n- The country of origin\n- The genre of music they worked in\n- Some key works    \n\n\nThis is a Pydantic model that defines a structured data format for storing information about composers:\n\n1. `class ComposerFactSheet(BaseModel)`: Creates a new class that inherits from Pydantic's `BaseModel`, giving it data validation capabilities.\n2. `name: str`: A required field for the composer's name.\n3. `birth_year: int`: A required field for the year of birth.\n4. `death_year: Optional[int] = None`: An optional field for the year of death.\n5. `country: str`: A required field for the country of origin.\n6. `genre: str`: A required field for the genre of music.\n7. `key_works: List[str]`: A required field for a list of key works.\n\n\nWhen used, this model will:\n\n- Validate that all required fields are present\n- Convert input data to the correct types when possible\n- Raise validation errors if data doesn't match the schema\n\nExample output:\n\n```python\ncomposer = ComposerFactSheet(\n    name=\"Johann Sebastian Bach\",\n    birth_year=1685,\n    death_year=1750,\n    country=\"Germany\",\n    genre=\"Baroque\",\n    key_works=[\"Mass in B minor\", \"The Well-Tempered Clavier\"]\n)\n```\n\n\n\nLet's try this with a suitable system prompt and a short paragraph about [Eric Satie](https://en.wikipedia.org/wiki/Erik_Satie). We will use the `GPT-4o` model for this.\n\n\nThe f-string (formatted string literal)is used to embed the `text` variable into the `user_message` string.\nThis allows us to dynamically construct the prompt that will be sent to the language model,\nincluding the specific text we want it to extract structured information from.\nWithout the f-string, we would need to concatenate the strings manually, which can be more error-prone and less readable.\n\n\n\nWe can now access the fields of the `factsheet` object.\n\nLet's try another example. This time we will attempt to extract information from a paragraph in which some of the information is missing.\n\n\nAn obvious next step would be to improve our prompting strategy, so that the model indicates which fields it is able to fill in, and which fields are associated with uncertain or missing information.\n\n## Creating a reusable function\nHowever, we will focus on making our code more resuable by creating a function that can be called with different texts.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"execute-dir":"project","engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"brand":{"brand":{"color":{"palette":{"dark-grey":"#222222","blue":"#ddeaf1"},"background":"blue","foreground":"dark-grey","primary":"black"},"typography":{"fonts":[{"family":"Jura","source":"google"}],"base":"Jura","headings":"Jura"}},"data":{"color":{"palette":{"dark-grey":"#222222","blue":"#ddeaf1"},"background":"blue","foreground":"dark-grey","primary":"black"},"typography":{"fonts":[{"family":"Jura","source":"google"}],"base":"Jura","headings":"Jura"}},"brandDir":"/Users/andrew/GitHub/sites/ai-education-assignments-2025","projectDir":"/Users/andrew/GitHub/sites/ai-education-assignments-2025","processedData":{"color":{"dark-grey":"#222222","blue":"#ddeaf1","background":"#ddeaf1","foreground":"#222222","primary":"black"},"typography":{"base":"Jura","headings":"Jura"},"logo":{"images":{}}}}},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["timer","custom-callout"],"toc":true,"output-file":"structured-output.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","page-footer":{"right":[{"icon":"github","href":"https://github.com/virtuelleakademie/ai-education-assignments-2025"}]},"comments":{"hypothesis":{"theme":"clean"}},"editor":{"render-on-save":true},"revealjs-plugins":["attribution"],"custom-callout":{"individual":{"title":"Individual Work","icon-symbol":"üíª","color":"steelblue","collapse":false},"pair":{"title":"Pair Work","icon-symbol":"üë•","color":"forestgreen","collapse":false},"group":{"title":"Group Work","icon-symbol":"üë•","color":"purple","collapse":false},"screens-down":{"title":"Screens Down","icon-symbol":"üîΩ","color":"orange","collapse":false},"screens-up":{"title":"Screens Up","icon-symbol":"üîº","color":"green","collapse":false},"try":{"title":"Try It","icon-symbol":"üîÑ","color":"blue","collapse":false},"reflect":{"title":"Reflection","icon-symbol":"üí≠","color":"purple","collapse":false},"feedback":{"title":"Feedback","icon-symbol":"üìù","color":"teal","collapse":true},"caution":{"title":"Watch Out","icon-symbol":"‚ö†Ô∏è","color":"orange","collapse":true},"pro-tip":{"title":"Pro Tip","icon-symbol":"üí°","color":"gold","collapse":true},"prompt-example":{"title":"Example Prompt","icon-symbol":"üë©üèº‚Äçüîß","color":"steelblue","collapse":false},"output-example":{"title":"Output Example","icon-symbol":"üìÑ","color":"purple","collapse":true},"prompt-template":{"title":"Prompt Template","icon-symbol":"üìã","color":"indigo","collapse":true},"testing":{"title":"Test Your Prompt","icon-symbol":"üß™","color":"green","collapse":false},"export":{"title":"Export","icon-symbol":"üì§","color":"brown","collapse":true},"setup":{"title":"Setup","icon-symbol":"‚öôÔ∏è","color":"gray","collapse":true},"timing":{"title":"Time Check","icon-symbol":"‚è±Ô∏è","color":"red","collapse":false},"break":{"title":"Break Time","icon-symbol":"‚òï","color":"yellow","collapse":false},"checkpoint":{"title":"Checkpoint","icon-symbol":"üéØ","color":"purple","collapse":false},"schedule":{"title":"Schedule","icon-symbol":"‚è∞Ô∏é","color":"steelblue","collapse":false}},"theme":{"light":"simplex"},"anchor-sections":true,"smooth-scroll":true,"linkcolor":"rebeccapurple","title":"Structured Output"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}